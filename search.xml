<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[管理学考纲]]></title>
    <url>%2F2019%2F02%2F03%2F%E4%B8%93%E6%8F%92%E6%9C%AC%2F%E7%AE%A1%E7%90%86%E5%AD%A6%2F%E7%AE%A1%E7%90%86%E5%AD%A6%E8%80%83%E7%BA%B2%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>专插本</category>
        <category>管理学</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[第五部分 控制]]></title>
    <url>%2F2019%2F02%2F03%2F%E4%B8%93%E6%8F%92%E6%9C%AC%2F%E7%AE%A1%E7%90%86%E5%AD%A6%2F%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86%20%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[第十五章 控制与控制过程 第十六章 控制方法]]></content>
      <categories>
        <category>专插本</category>
        <category>管理学</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[第四部分 领导]]></title>
    <url>%2F2019%2F02%2F03%2F%E4%B8%93%E6%8F%92%E6%9C%AC%2F%E7%AE%A1%E7%90%86%E5%AD%A6%2F%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86%20%E9%A2%86%E5%AF%BC%2F</url>
    <content type="text"><![CDATA[第十二章 领导概论 第十三章 激励 第十四章 沟通]]></content>
      <categories>
        <category>专插本</category>
        <category>管理学</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[第三部分 组织]]></title>
    <url>%2F2019%2F02%2F03%2F%E4%B8%93%E6%8F%92%E6%9C%AC%2F%E7%AE%A1%E7%90%86%E5%AD%A6%2F%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%20%E7%BB%84%E7%BB%87%2F</url>
    <content type="text"><![CDATA[第九章 组织设计 第十章 人力资源管理 第十一章 组织变革与组织变化]]></content>
      <categories>
        <category>专插本</category>
        <category>管理学</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[第二部分 决策与计划]]></title>
    <url>%2F2019%2F02%2F03%2F%E4%B8%93%E6%8F%92%E6%9C%AC%2F%E7%AE%A1%E7%90%86%E5%AD%A6%2F%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%20%E5%86%B3%E7%AD%96%E4%B8%8E%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[第六章 决策与决策方法 第七章 计划与计划工作 第八章 战略性计划与计划实施]]></content>
      <categories>
        <category>专插本</category>
        <category>管理学</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[第一部分 总论]]></title>
    <url>%2F2019%2F02%2F03%2F%E4%B8%93%E6%8F%92%E6%9C%AC%2F%E7%AE%A1%E7%90%86%E5%AD%A6%2F%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%20%E6%80%BB%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[第一章 管理与管理学 第二章 管理理论的形成与发展 第三章 管理道德与企业责任 第四章 全球化与管理 第五章 信息与信息化管理]]></content>
      <categories>
        <category>专插本</category>
        <category>管理学</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[常见句型]]></title>
    <url>%2F2018%2F03%2F07%2F%E6%97%A5%E8%AF%AD%2F%E5%B8%B8%E8%A7%81%E5%8F%A5%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[最最简单的句型 A は B です。A 是 B。 A は B では ありません。A 不是 B。 A ですが。是 A 吗？日语中通常不加问号，用句号。]]></content>
      <categories>
        <category>日语</category>
      </categories>
      <tags>
        <tag>日语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[声调]]></title>
    <url>%2F2018%2F03%2F05%2F%E6%97%A5%E8%AF%AD%2F%E5%A3%B0%E8%B0%83%2F</url>
    <content type="text"><![CDATA[声调日语的声调是高低型的，由高而低或由低而高。一个假名代表一拍，包括表示清音、浊音、半浊音、促音、拨音以及长音的假名，但是不包括组成拗音中的小“や”、“ゆ”和“よ”，即一个拗音整体上作为一个音拍来看待，如“きゅ”是一个音拍，而不是两拍。而“きゅう”和“くう”等长音则是两拍。 ⓪代表的是，第一拍是低音，从第二拍开始都是高音。 ①代表的是，第一拍是高音，从第二拍开始都是低音。（⓪调和①调正好相反。） ②代表的是，第一拍是低音，第二拍是高音，第三拍开始后面都是低音。 ③代表的是，第一拍是低音，第二拍到第三拍是高音，从第四拍开始都是低音。 ④代表的是，第一拍是低音，第二拍到第四拍是高音，从第五拍开始都是低音。 ⑤⑥⑦⑧依此类推。]]></content>
      <categories>
        <category>日语</category>
      </categories>
      <tags>
        <tag>日语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[less calc问题]]></title>
    <url>%2F2018%2F01%2F12%2FCSS%2Fless%20calc%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题在 less 中使用 css3 的 calc() 函数时，less 会把函数内容当成表达式计算，编译成 css 后会返回计算后的结果。如： 1height: calc(100% - 60px); 会被编译成： 1height: calc(60%); 解决办法1234567height: calc(~"100% - 60px");// orheight: e("calc(100% - 60px)");// 如果有变量height: calc(~"100% - @&#123;var&#125;");height: e("calc(100% - @&#123;var&#125;)");]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>Less</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chrome、firefox、IE奇葩的不同细节.md]]></title>
    <url>%2F2017%2F12%2F31%2F%E5%85%B6%E5%AE%83%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%2Fchrome%E3%80%81firefox%E3%80%81IE%E5%A5%87%E8%91%A9%E7%9A%84%E4%B8%8D%E5%90%8C%E7%BB%86%E8%8A%82%2F</url>
    <content type="text"><![CDATA[getComputedStyle 的 url()chrome 和 firefox 下得到的结果为 url(&quot;path/to/file&quot;) 有双引号IE 下得到的结果为 url(path/to/file) 没有双引号]]></content>
      <categories>
        <category>其它</category>
        <category>浏览器兼容</category>
      </categories>
      <tags>
        <tag>browser</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm相关]]></title>
    <url>%2F2017%2F12%2F30%2F%E5%85%B6%E5%AE%83%2Fnpm%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[npm包初始化1npm init 发布npm包12npm loginnpm publish 发布包的时候要记住切换到 npm 的官方源。 切换NPM源 123456 // 全局切换到官方源 npm config set registry http://www.npmjs.org // 全局切换到淘宝源 npm config set registry https://registry.npm.taobao.org // 临时切换到淘宝源npm --registry https://registry.npm.taobao.org install anyonepackage 使npm包拥有全局命令行工具在 npm 包的 package.json 下新增一个bin对象： 123"bin": &#123; "command": "path/to/file.js"&#125; 如果命令指向的文件是 js 文件，需要在 js 文件开始一行加入: 1#!/usr/bin/env node]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>other</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[inline-block下沉问题]]></title>
    <url>%2F2017%2F12%2F25%2FCSS%2Finline-block%E4%B8%8B%E6%B2%89%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题在将一排 div 设置为 inline-block 时，如果这些 div 中有的有文字，有的没有文字，那么有文字的 div 就会下沉。 1234567891011&lt;div&gt;lala&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;en&lt;/div&gt;&lt;style&gt; div &#123; width: 50px; height: 50px; display: inline-block; margin: 5px; background-color: yellowgreen; &#125; 解决办法解决办法是将 div 的垂直对齐方式改为顶端对齐。 123div&#123; vertical-align: top;&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[30.扩大可点击区域]]></title>
    <url>%2F2017%2F12%2F13%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2FCSS%E6%8F%AD%E7%A7%98%2F30.%E6%89%A9%E5%A4%A7%E5%8F%AF%E7%82%B9%E5%87%BB%E5%8C%BA%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[使用伪元素在按钮的上层覆盖一层透明的伪元素，并让伪元素在四个方向上都比宿主元素大出一定的尺寸。123456789button&#123; position: relative;&#125;button::after&#123; content: ''; position: absolute; top: -10px; left: -10px; bottom: -10px; right: -10px;&#125;]]></content>
      <categories>
        <category>读书笔记</category>
        <category>CSS揭秘</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第10章 DOM]]></title>
    <url>%2F2017%2F11%2F11%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2FJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%2F%E7%AC%AC10%E7%AB%A0%20DOM%2F</url>
    <content type="text"><![CDATA[10.1 节点层次Node类型JavaScript的所有节点类型都继承自 Node 类型。每个节点类型都有一个 nodeType 属性,节点类型的定义在 Node 类型的常量中。123456789101112Node.ELEMENT_NODE // 1Node.ATTRIBUTE_NODE // 2Node.TEXT_NODE // 3Node.CDATA_SECTION_NODE // 4Node.ENTITY_REFERENCE_NODE // 5Node.ENTITY_NODE // 6Node.PROCESSING_INSTRUCTION_NODE // 7Node.COMMENT_NODE // 8Node.DOCUMENT_NODE // 9Node.DOCUMENT_TYPE_NODE // 10Node.DOCUMENT_FRAGMENT_NODE // 11Node.NOTATION_NODE // 12 Document 类型 Element 类型 Text 类型 CDATASection 类型 DocumentType 类型 DocumentFragment 类型 Attr 类型 DOM 扩展滚动 scrollIntoView(alignWithTop) 浏览器会滚动到自身顶部与元素顶部平齐。 1aElement.scrollIntoView(); scrollIntoViewIfNeeded(alignCenter) 当前元素在浏览器可视窗口不可见的情况下，浏览器会滚动到使元素可见。 alignCenter 为 true 时表示滚动到视口中间。 1aElement.scrollIntoViewIfNeeded(); scrollByLines() scrollByPages()]]></content>
      <categories>
        <category>读书笔记</category>
        <category>JavaScript高级程序设计</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM文本节点内容属性]]></title>
    <url>%2F2017%2F11%2F10%2FJavaScript%2FDOM%E6%96%87%E6%9C%AC%E8%8A%82%E7%82%B9%E5%86%85%E5%AE%B9%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[DOM 文本节点 Text.nodeValue 属性返回或设置当前节点的值。 CharacterData.data 属性表示该对象中包含的文本数据。 Node.textContent 属性表示一个节点及其后代的文本内容。 Text.wholeText 属性表示一个节点及其后代的文本内容（只读）。 CharacterData 继承于 Node。Node.nodeValue 和 CharacterData.data 基本相同。Node.textContent 和 Text.wholeText 基本相同。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变量提升（Hoisting）]]></title>
    <url>%2F2017%2F11%2F10%2FJavaScript%2F%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%EF%BC%88Hoisting%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在编译阶段将变量和函数声明放入内存中，但仍然保留在编码中键入的位置。例如：函数和变量可以在声明之前调用：12345678catName("Tigger");function catName(name) &#123; console.log("My cat's name is " + name);&#125;foo = 2;var foo; 但是使用匿名函数赋值创建的函数不存在变量提升：12345catName("Tigger"); // catName is not definedlet catName = function(name) &#123; console.log("My cat's name is " + name);&#125; let 也不存在变量提升。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回到顶部（document.documentElement.scrollTop）]]></title>
    <url>%2F2017%2F11%2F10%2FJavaScript%2F%E5%9B%9E%E5%88%B0%E9%A1%B6%E9%83%A8%EF%BC%88document.documentElement.scrollTop%EF%BC%89%2F</url>
    <content type="text"><![CDATA[要获取当前页面的滚动条纵坐标位置，用：1document.documentElement.scrollTop 而不是：1document.body.scrollTop documentElement 对应的是 &lt;html&gt; 标签，而 body 对应的是 &lt;body&gt; 标签。在标准w3c下，document.body.scrollTop恒为0，需要用document.documentElement.scrollTop来代替。可以对 document.documentElement.scrollTop 赋值实现页面滚动（回到顶部）。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件处理注意]]></title>
    <url>%2F2017%2F11%2F10%2FJavaScript%2F%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%B3%A8%E6%84%8F%2F</url>
    <content type="text"><![CDATA[事件处理函数中的 return ： 当返回的是 true 时，将继续操作。 当返回是 false 时，将中断操作。 当不加return时将不会对 window.event.returnvalue 进行设置，所以会默认地继续执行操作。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第6章 面向对象的程序设计]]></title>
    <url>%2F2017%2F11%2F10%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2FJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%2F%E7%AC%AC6%E7%AB%A0%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[6.1 创建对象创建对象的三个方法 工厂模式12345678910111213141516171819202122232425262728293031323334353637383940414243444546function createObject(name) &#123; let o = new Object(); o.name = name; o.sayName = function() &#123; console.log(this.name); &#125; return o;&#125; let object1 = createObject('lala');let object2 = createObject('lala');``` 2. 构造函数模式```jsfunction _Object(name) &#123; this.name = name; this.sayName = function() &#123; console.log(this.name); &#125;&#125; let object1 = new _Object('lala');let object2 = new _Object('lala');``` 3. 原型模式```js function _Object() &#123;&#125; _Object.prototype.name = 'lala'; _Object.sayName = function() &#123; console.log(this.name);&#125; let object1 = new _Object();``` ## 常见的创建对象的方法（组合使用构造函数模式和原型模式）构造函数模式用于定义实例属性，原型模式用于定义方法和共享的属性。```jsfunction _Object(name) &#123; this.name = name;&#125;_Object.prototype.sayName = function() &#123; console.log(this.name);&#125;let object1 = new _Object('lala');]]></content>
      <categories>
        <category>读书笔记</category>
        <category>JavaScript高级程序设计</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Math对象]]></title>
    <url>%2F2017%2F11%2F10%2FJavaScript%2FMath%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[Math.min() 和 Math.max() 方法用于确定一组数值中的最小值和最大值，接受任意多个数值参数。 舍入方法： Math.ceil() 执行向上舍入 Math.floor() 执行向下舍入 Math.round() 执行标准舍入 随机数： Math.random() 返回0和1之间的随机数，不包括0和1。 利用以下公式可以从某个整数范围内随机选择一个整数值： 值 = Math.floor(Math.random() - 可能值的总数 + 第一个可能的数值) Math.abs(num) 返回 num 的绝对值。 Math.pow(num, power) 返回 num 的 power 次幂。 Math.sqrt(num) 返回 num 的平方根。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2F2017%2F11%2F10%2FJavaScript%2F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序：比较相邻两个元素，如果第一个元素比第二个元素大，则交换他们两个。 123456789Array.prototype.bubble_sort = function() &#123; var i, j; for (i = 0; i &lt; this.length - 1; i++) for (j = 0; j &lt; this.length - 1 - i; j++) if (this[j] &gt; this[j + 1]) &#123; [this[j], this[j + 1]] = [this[j + 1], this[j]]; &#125; return this;&#125;; 选择排序： 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 12345678910Array.prototype.selection_sort = function() &#123; let i, j, min; for (i = 0; i &lt; this.length - 1; i++) &#123; min = i; for (j = i + 1; j &lt; this.length; j++) if (this[min] &gt; this[j]) min = j; [this[min], this[i]] = [this[i], this[min]]; &#125;&#125;;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清除浮动]]></title>
    <url>%2F2017%2F11%2F10%2FCSS%2F%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[overflow属性给浮动元素的容器添加overflow属性 1overflow: auto | hidden | overlay | scroll; display: flow-root将浮动元素容器的display属性值设为flow-root（兼容性较差，目前[2017/10/08]只有chrome、firefox、opera支持） 1display: flow-root; 带有clear属性的空元素在浮动元素后使用一个空元素，设置clear属性 1234567&lt;style&gt;.clear&#123;clear: both;&#125;&lt;/style&gt;&lt;!-- 浮动的元素 --&gt;&lt;div class="float"&gt;&lt;/div&gt;&lt;!-- 用于清除浮动的空元素 --&gt;&lt;div class="clear"&gt;&lt;/div&gt; :after伪元素使用:after伪元素给浮动元素容器内部末尾添加一个隐藏块元素，为块元素设置clear属性 12345.container:after &#123; content: ''; display: block; clear: both;&#125; 给浮动元素容器添加浮动1.container &#123;float: left;&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包]]></title>
    <url>%2F2017%2F11%2F10%2FJavaScript%2F%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[可以引用在当前函数以外定义的变量。 即使外部函数已经返回，当前函数仍然可以引用在外部函数定义的变量。 闭包可以更新外部变量的值。 参考：《Effective Javacript》第11条：熟练掌握闭包]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第3章 对象]]></title>
    <url>%2F2017%2F11%2F10%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2FJavaScript%E8%AF%AD%E8%A8%80%E7%B2%BE%E7%B2%B9%2F%E7%AC%AC3%E7%AB%A0%20%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[3.4 引用 对象通过引用来传递，它们永远不会被拷贝（包括Array）。 对于不存在函数属性的对象，可以通过JSON的方法来实现深复制。 1let newObject = JSON.parse(JSON.stringify(object)); 浅复制只复制一层对象的属性，而深复制则递归复制了所有层级。如果对象存在函数属性，则该属性会被忽略，不会在新对象中出现。]]></content>
      <categories>
        <category>读书笔记</category>
        <category>JavaScript语言精粹</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第7章 匿名函数]]></title>
    <url>%2F2017%2F11%2F10%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2FJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%2F%E7%AC%AC7%E7%AB%A0%20%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[7.1 递归在匿名函数中调用自身时使用 arguments.callee 代替函数名。]]></content>
      <categories>
        <category>读书笔记</category>
        <category>JavaScript高级程序设计</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页马赛克效果]]></title>
    <url>%2F2017%2F06%2F11%2Fweb-demo%2F%E7%BD%91%E9%A1%B5%E9%A9%AC%E8%B5%9B%E5%85%8B%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[text-shadow 方法将文字颜色设为透明，加上 text-shadow 来模拟模糊效果 1&lt;p&gt;这是一段非常非常私密的文字。&lt;/p&gt; 1234p &#123; color: transparent; text-shadow: 0 0 10px rgba(0, 0, 0, 0.5); &#125; 但是这样有一个问题，就是对文字进行选择时，会暴露文字内容。 解决办法是使用css的伪元素选择器selection： 1234p::selection &#123; color: transparent; background: transparent; &#125; 或者直接使文字不可选： 123p &#123; user-select: none; &#125; css 滤镜 filter 方法1&lt;p&gt;这是一段非常非常私密的文字。&lt;/p&gt; 123p &#123; filter: blur(.3em);&#125;]]></content>
      <categories>
        <category>web-demo</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片轮播]]></title>
    <url>%2F2017%2F06%2F03%2Fweb-demo%2F%E5%9B%BE%E7%89%87%E8%BD%AE%E6%92%AD%2F</url>
    <content type="text"><![CDATA[图片轮播实现原理把需要在展示的图片全部在一行上平铺排列，在可见部分只显示一张图片，通过设置图片偏移切换显示的图片，用setInterval()自动切换。 html结构123456789101112&lt;!-- index.html --&gt;&lt;div id="container"&gt; &lt;ul class="slider" onmouseover="stop()" onmouseout="play()"&gt; &lt;li class="slide-li"&gt;&lt;a href=""&gt;&lt;img src="img/1.jpg" alt="img1"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class="slide-li"&gt;&lt;a href=""&gt;&lt;img src="img/2.jpg" alt="img2"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class="slide-li"&gt;&lt;a href=""&gt;&lt;img src="img/3.jpg" alt="img3"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class="slide-li"&gt;&lt;a href=""&gt;&lt;img src="img/4.jpg" alt="img4"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;!-- 手动左右切换图片按钮 --&gt; &lt;div class="button" id="prev"&gt;&lt;p&gt;&amp;lt;&lt;/p&gt;&lt;/div&gt; &lt;div class="button" id="next"&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt; css12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/* css/style.css */* &#123; margin: 0; padding: 0;&#125;/*overflow隐藏其他的图片*/#container &#123; width: 1000px; height: 370px; margin: 50px auto auto auto; border-radius: 10px; overflow: hidden;&#125;/*width值要大于所有图片加起来的宽度，否则图片会换行*/.slider &#123; width: 500%; height: 100%; list-style: none; position: relative; transition: left 0.3s ease-out;&#125;/*使图片显示在一行上*/.slider li &#123; float: left;&#125;.slider li img &#123; width: 1000px;&#125;.button &#123; position: relative; bottom: 240px; font-size: 4em; color: white; margin: 10px; cursor: pointer; z-index: 2;&#125;.button:hover &#123; color: gray;&#125;#prev &#123; float: left;&#125;#next &#123; float: right;&#125; js给切换按钮绑定onclick操作 123&lt;!-- index.html --&gt;&lt;div class="button" id="prev" onclick="prev()"&gt;&lt;p&gt;&amp;lt;&lt;/p&gt;&lt;/div&gt;&lt;div class="button" id="next" onclick="next()"&gt;&lt;p&gt;&amp;gt;&lt;/p&gt;&lt;/div&gt; 12345678910111213141516171819202122// js/script.jsfunction prev() &#123; let slider = document.getElementsByClassName('slider')[0]; let offset = parseInt(slider.style.left); console.log(offset); if (offset &gt;= 0) &#123; slider.style.left = '-3000px'; &#125; else &#123; slider.style.left = offset + 1000 + 'px'; &#125;&#125;function next() &#123; let slider = document.getElementsByClassName('slider')[0]; let offset = parseInt(slider.style.left); console.log(offset); if (offset &lt;= -3000) &#123; slider.style.left = '0'; &#125; else &#123; slider.style.left = offset - 1000 + 'px'; &#125;&#125; 注意：js中document.getElementById().style不能修改外部css文件中的样式，只能修改html元素的style属性设置的样式 修改index.html 1234&lt;!-- index.html --&gt;&lt;ul class="slider" style="left: 0;"&gt; ... ...&lt;/ul&gt; 使用setInterval()自动切换图片，鼠标移到container上时用clearInterval()暂停自动切换 123456789// js/script.jslet player;function play() &#123; player = setInterval(next, 3000);&#125;function stop() &#123; clearInterval(player);&#125;play(); 最后效果：https://yokoee.github.io/web-demo/SlideShow/]]></content>
      <categories>
        <category>web-demo</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP跨域请求]]></title>
    <url>%2F2017%2F04%2F18%2FHTTP%2FHTTP%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[问题在网页中向其它域名或端口请求资源时，就会发起跨域 HTTP 请求（cross-origin- HTTP request）。浏览器会限制脚本中发起的跨域请求（有些浏览器还不允许从 HTTPS 的域跨域访问 HTTP），但不会限制通过 HTML 标签中的 src 属性加载其它站点的资源。使用ajax发起跨域请求会抛出错误： 1No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource. Origin &apos;null&apos; is therefore not allowed access. The response had HTTP status code 400. 解决办法解决办法是在服务器端的响应中加上如下响应头： 1Access-Control-Allow-Origin: &lt;origin&gt; &lt;origin&gt; 表示允许访问该资源的外域URI，如果不需要限制外域的请求，可将 &lt;origin&gt; 更换为通配符*： 1Access-Control-Allow-Origin: * 参考：HTTP访问控制（CORS） - HTTP | MDN]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
</search>
